---
// src/components/BlogPostForm.astro
// Este componente maneja el formulario para crear y editar posts de blog.

// Props:
// - postId: String, opcional. Si se proporciona, estamos en modo edición.
const { postId } = Astro.props;

// Inicializamos postToEdit como null. Los datos se cargarán dinámicamente en el cliente.
let postToEdit = null;
---

<form id="post-form" data-post-id={postId}>
  <h2>{postId ? 'Editar Post' : 'Crear Nuevo Post'}</h2>

  <h3>Traducciones (Español)</h3>
  <label>
    Título (ES):
    <input type="text" name="title_es" value={postToEdit?.translations?.es?.title || ''} required />
  </label>
  <label>
    Contenido (ES):
    <textarea name="content_es" id="content_es_editor" rows="10">{postToEdit?.translations?.es?.content || ''}</textarea>
  </label>
  <label>
    Resumen (ES):
    <textarea name="excerpt_es" id="excerpt_es_editor" rows="3">{postToEdit?.translations?.es?.excerpt || ''}</textarea>
  </label>


  <h3>Traducciones (Inglés)</h3>
  <label>
    Título (EN):
    <input type="text" name="title_en" value={postToEdit?.translations?.en?.title || ''} />
  </label>
  <label>
    Contenido (EN):
    <textarea name="content_en" id="content_en_editor" rows="10">{postToEdit?.translations?.en?.content || ''}</textarea>
  </label>
  <label>
    Resumen (EN):
    <textarea name="excerpt_en" id="excerpt_en_editor" rows="3">{postToEdit?.translations?.en?.excerpt || ''}</textarea>
  </label>


  <label>
    Categorías (separadas por comas):
    <input type="text" name="categories" value={postToEdit?.categories?.join(',') || ''} />
  </label>

  <label>
    Imagen de Portada:
    <input type="file" name="coverImageFile" id="coverImageFileInput" />
    <div id="current-cover-image-display-area">
      </div>
    
    <label id="clear-image-option" style="display: block; margin-top: 10px; display: none;">
        <input type="checkbox" name="coverImage_clear_flag" value="true" /> Eliminar imagen actual
    </label>
  </label>

  <label>
    Fecha de Publicación:
    <input type="date" name="pubDate"
           value={postToEdit?.pubDate ? new Date(postToEdit.pubDate).toISOString().split('T')[0] : new Date().toISOString().split('T')[0]} />
  </label>

  <label>
    <input type="checkbox" name="draft" {postToEdit?.draft ? 'checked' : ''} /> Es Borrador
  </label>

  <button type="submit">{postId ? 'Actualizar Post' : 'Crear Post'}</button>
</form>

<script type="module">
  import { auth } from '/src/lib/firebase-config-client';
  import { onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/9.0.0/firebase-auth.js'; // Usando CDN para Auth

  const form = document.getElementById('post-form');
  const postId = form.dataset.postId; // Obtener el ID del post si estamos en modo edición
  const postToEditData = { /* Usaremos este objeto para almacenar los datos cargados dinámicamente */ };


  // --- Inicializar TinyMCE ---
  // YA NO NECESITAMOS VARIABLES GLOBALES para las instancias de editor
  // Accederemos a ellas con tinymce.get('ID_DEL_EDITOR')
  function initializeTinyMCE() {
    if (typeof tinymce === 'undefined') {
      console.warn("TinyMCE no está cargado. Reintentando en 100ms...");
      setTimeout(initializeTinyMCE, 100); // Reintentar si TinyMCE no está listo
      return;
    }

    // Asegurarse de que el editor no esté ya inicializado en el mismo selector
    // y si lo está, destruirlo para evitar errores.
    ['content_es_editor', 'excerpt_es_editor', 'content_en_editor', 'excerpt_en_editor'].forEach(id => {
        if (tinymce.get(id)) {
            tinymce.get(id).destroy();
        }
    });

    tinymce.init({
      selector: '#content_es_editor',
      plugins: 'advlist link image lists code table media wordcount',
      toolbar: 'undo redo | formatselect | bold italic | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | link image | code',
      height: 300,
      // No necesitamos setup aquí, accedemos con tinymce.get()
    });

    tinymce.init({
      selector: '#excerpt_es_editor',
      plugins: 'wordcount',
      toolbar: 'undo redo | bold italic',
      height: 150,
      menubar: false,
    });

    tinymce.init({
      selector: '#content_en_editor',
      plugins: 'advlist link image lists code table media wordcount',
      toolbar: 'undo redo | formatselect | bold italic | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | link image | code',
      height: 300,
    });

    tinymce.init({
      selector: '#excerpt_en_editor',
      plugins: 'wordcount',
      toolbar: 'undo redo | bold italic',
      height: 150,
      menubar: false,
    });
  }

  // Inicializar TinyMCE cuando el DOM esté completamente cargado
  document.addEventListener('DOMContentLoaded', initializeTinyMCE);


  // --- Función para cargar datos del post en el CLIENTE después de la autenticación ---
  async function loadPostDataForEdit(currentPostId, idToken) {
    if (!currentPostId) return;

    try {
      const response = await fetch(`/api/blog/${currentPostId}`, {
        headers: { 'Authorization': `Bearer ${idToken}` },
      });
      const data = await response.json();

      if (response.ok) {
        Object.assign(postToEditData, data);
        populateForm(postToEditData);
      } else {
        console.error(`[BlogPostForm.astro] Error al cargar post ${currentPostId} para edición:`, data.error);
        alert(`Error al cargar el post para editar: ${data.error}`);
      }
    } catch (error) {
      console.error(`[BlogPostForm.astro] Error de red al cargar post ${currentPostId}:`, error);
      alert(`Error de red al cargar el post: ${error.message}`);
    }
  }

  // --- Función para rellenar los campos del formulario (incluyendo TinyMCE) ---
  function populateForm(data) {
    if (!data) return;

    // Rellenar campos de texto estándar
    form.querySelector('[name="title_es"]').value = data.translations?.es?.title || '';
    form.querySelector('[name="title_en"]').value = data.translations?.en?.title || '';
    form.querySelector('[name="categories"]').value = data.categories?.join(',') || '';
    if (data.pubDate) {
        form.querySelector('[name="pubDate"]').value = new Date(data.pubDate).toISOString().split('T')[0];
    } else {
        form.querySelector('[name="pubDate"]').value = new Date().toISOString().split('T')[0];
    }
    form.querySelector('[name="draft"]').checked = data.draft || false;

    // Rellenar editores TinyMCE, usando tinymce.get() para asegurar la instancia correcta
    // Usamos setTimeout para dar tiempo a TinyMCE a inicializarse completamente
    setTimeout(() => {
        if (tinymce.get('content_es_editor')) tinymce.get('content_es_editor').setContent(data.translations?.es?.content || '');
        if (tinymce.get('excerpt_es_editor')) tinymce.get('excerpt_es_editor').setContent(data.translations?.es?.excerpt || '');
        if (tinymce.get('content_en_editor')) tinymce.get('content_en_editor').setContent(data.translations?.en?.content || '');
        if (tinymce.get('excerpt_en_editor')) tinymce.get('excerpt_en_editor').setContent(data.translations?.en?.excerpt || '');
    }, 500); // Pequeña demora para asegurar que el editor está listo
    
    // --- Lógica para mostrar/ocultar y manipular la imagen de portada ---
    const imageDisplayArea = form.querySelector('#current-cover-image-display-area');
    let imgElement = imageDisplayArea.querySelector('.current-cover-image');
    const clearImageOptionLabel = form.querySelector('#clear-image-option');
    const clearCheckbox = clearImageOptionLabel ? clearImageOptionLabel.querySelector('[name="coverImage_clear_flag"]') : null;

    if (data.coverImage) {
        if (!imgElement) {
            imgElement = document.createElement('img');
            imgElement.className = 'current-cover-image';
            imgElement.style.maxWidth = '150px';
            imgElement.style.marginTop = '10px';
            imageDisplayArea.appendChild(imgElement);
        }
        imgElement.src = data.coverImage;
        imgElement.style.display = 'block';

        if (clearImageOptionLabel) clearImageOptionLabel.style.display = 'block';
        if (clearCheckbox) clearCheckbox.checked = false;
    } else {
        if (imgElement) {
            imgElement.src = '';
            imgElement.style.display = 'none';
        }
        if (clearImageOptionLabel) clearImageOptionLabel.style.display = 'none';
        if (clearCheckbox) clearCheckbox.checked = false;
    }
  }


  // --- Event Listener para el envío del formulario ---
  form.addEventListener('submit', async (e) => {
    e.preventDefault();

    const user = auth.currentUser;
    if (!user) {
      alert('Debes iniciar sesión para realizar esta operación.');
      window.location.href = '/admin/login';
      return;
    }

    const idToken = await user.getIdToken();

    const formData = new FormData(form);

    // --- OBTENER CONTENIDO DE TinyMCE y añadirlo a formData ---
    // TinyMCE no actualiza automáticamente el textarea, hay que extraer su contenido.
    // Usamos tinymce.get() para asegurar que obtenemos la instancia correcta del editor.
    formData.set('content_es', tinymce.get('content_es_editor') ? tinymce.get('content_es_editor').getContent() : form.querySelector('[name="content_es"]').value);
    formData.set('excerpt_es', tinymce.get('excerpt_es_editor') ? tinymce.get('excerpt_es_editor').getContent() : form.querySelector('[name="excerpt_es"]').value);
    formData.set('content_en', tinymce.get('content_en_editor') ? tinymce.get('content_en_editor').getContent() : form.querySelector('[name="content_en"]').value);
    formData.set('excerpt_en', tinymce.get('excerpt_en_editor') ? tinymce.get('excerpt_en_editor').getContent() : form.querySelector('[name="excerpt_en"]').value);


    // Asegurarse de que los campos anidados existan y tengan valores por defecto (ej. string vacío)
    const postData = {
        translations: {
            es: {
                title: formData.get('title_es') || '',
                content: formData.get('content_es') || '',
                excerpt: formData.get('excerpt_es') || '',
            },
            en: {
                title: formData.get('title_en') || '',
                content: formData.get('content_en') || '',
                excerpt: formData.get('excerpt_en') || '',
            },
        },
        categories: formData.get('categories')?.split(',').map(cat => cat.trim()).filter(cat => cat) || [],
        pubDate: formData.get('pubDate') || '',
        draft: formData.get('draft') === 'on' ? true : false,
    };

    // Lógica para el campo 'coverImage'
    const coverImageFile = formData.get('coverImageFile');
    const clearImageFlag = formData.get('coverImage_clear_flag') === 'true';

    if (coverImageFile && coverImageFile.size > 0) {
        // Si hay un nuevo archivo, el servidor lo manejará. No incluir 'coverImage' en postData aquí.
    } else if (clearImageFlag) {
        postData.coverImage = null; // Si se marcó para borrar
    }
    // Si no hay nuevo archivo y NO se marcó para borrar, no incluimos la propiedad
    // 'coverImage' en postData. updateDoc no tocará los campos no presentes.


    const method = postId ? 'PUT' : 'POST';
    const url = postId ? `/api/blog/${postId}` : '/api/blog';

    try {
      const response = await fetch(url, {
        method: method,
        body: formData, // FormData maneja archivos y campos de texto
        headers: {
          'Authorization': `Bearer ${idToken}`,
        },
      });

      const result = await response.json();

      if (response.ok) {
        alert('Operación exitosa!');
        window.location.href = '/admin/posts';
      } else {
        alert('Error en la operación: ' + result.error);
        console.error('Error del servidor:', result.error);
      }
    } catch (error) {
      console.error("Error al enviar el formulario (red o desconocido):", error);
      alert('Error de red o desconocido: ' + error.message);
    }
  });


  // --- Event Listener para cuando la autenticación cambia (y al cargar la página) ---
  onAuthStateChanged(auth, (user) => {
    if (user) {
      if (postId) {
        user.getIdToken().then(idToken => {
          loadPostDataForEdit(postId, idToken);
        });
      }
    } else {
      alert('No autenticado. Por favor, inicia sesión.');
      window.location.href = '/admin/login';
    }
  });

</script>

<style>
  /* Estilos básicos para el formulario */
  form {
    max-width: 800px;
    margin: 20px auto;
    padding: 30px;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    background-color: #fff;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  }
  h2 {
    text-align: center;
    margin-bottom: 25px;
    color: #333;
  }
  h3 {
    margin-top: 25px;
    margin-bottom: 15px;
    color: #444;
  }
  label {
    display: block;
    margin-bottom: 15px;
    font-weight: bold;
    color: #555;
  }
  input[type="text"],
  input[type="date"],
  textarea {
    width: calc(100% - 22px);
    padding: 10px;
    margin-top: 5px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 16px;
    box-sizing: border-box; /* Incluye padding y border en el width */
  }
  input[type="file"] {
    margin-top: 5px;
  }
  input[type="checkbox"] {
    margin-right: 10px;
  }
  button[type="submit"] {
    display: block;
    width: 100%;
    padding: 12px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 5px;
    font-size: 18px;
    cursor: pointer;
    margin-top: 25px;
  }
  button[type="submit"]:hover {
    background-color: #0056b3;
  }
  img {
    display: block;
    margin-top: 10px;
    border: 1px solid #eee;
    border-radius: 4px;
  }
</style>